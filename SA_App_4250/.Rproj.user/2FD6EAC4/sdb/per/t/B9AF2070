{
    "contents" : "##########\n##########\n# SA_function.R\n# define all functions\n##########\n### List of all functions\n# GetLngLat:\tget the longitude and lattitude of the transaction\n# GetResult:\tapply model result to test set\n# GetInd:\t\t\tget indicators for each model\n### Old functions - in S_function_old.R\n\n##########\n# ??? parameters to be justified or modified\n# GetInd:\nparam.ind3 <- 5 # weight of Ind3 in calculation of Ind\n# Model:\nparam.min.noPsg = 5            # low limit for choosing the result\nparam.min.nb.for.cluster = 10  # lower than which we won't clustering\nparam.max.nb.cluster = 3\t\t\t # the max number of cluster we'll test when choosing the number of cluster\nparam.model.2 = .3\t\t\t\t\t\t # low limit for choosing the ID-OD for Model.2 Space - Time\n#getModelunits : \nparam.SDWprnoW <- 0.060\n\nGetNumberDays <- function (period){\n  result <- period %>%\n    summarise (\n      D0 = sum(DOW == 0),\n      D1 = sum(DOW == 1),\n      D2 = sum(DOW == 2),\n      D3 = sum(DOW == 3),\n      D4 = sum(DOW == 4),\n      D5 = sum(DOW == 5),\n      D6 = sum(DOW == 6),\n      Weekdays = sum(DOW == 1 | DOW == 2 | DOW == 3 | DOW == 4 | DOW == 5),\n      Weekends = sum(DOW == 0 | DOW == 6)\n      )\n  return (result)\n}\n\nGetLngLat <- function(transaction) {\n  # Add longitude and lattitude to the transaction\n  # Args:\n  #\t  tansaction:\tEntr, Sor, ...\n  # Returns:\n  #\t  tansaction:\tEntr, Sor, ..., ELng, ELat, SLng, SLat\n\n  ### !!! to be removed\n  #   transaction$Entr <- as.numeric(transaction$Entr)\n  #   transaction$Sor <- as.numeric(transaction$Sor)\n  cde <- gares %>% transmute(Entr = Cde, ELng = Lng, ELat = Lat)\n  transaction <- left_join(transaction, cde, by = \"Entr\")\n  names(cde) <- c(\"Sor\", \"SLng\", \"SLat\")\n  transaction <- left_join(transaction, cde, by = \"Sor\")\n  return(transaction)\t\n}\n\nGetResult <- function(test, result) {\n  # Identify the passage in the test set that the model could predict\n  # Args:\n  #\t  test: ID Entr Sor Date DOW WOY TimeEntr TimeSor Sens SensEntr SensSor\n  #\t  result: ID Entr Sor SensEntr SensSor Sens DOW Tmin Tmax noPsg\n\n  # !!! removed when modify data_preparation\n  # test$DOW <- as.numeric(test$DOW)\n  test$result <- 0\n  name <- names(test)\n\t# temp <- inner_join(test, result, by = c(\"ID\", \"Entr\", \"Sor\", \"SensEntr\", \"SensSor\",\"Sens\", \"DOW\"))\n\ttemp <- inner_join(test, result, by = c(\"ID\", \"OD\", \"DOW\"))\n  temp[temp$TimeSor >= temp$Tmin & temp$TimeSor <= temp$Tmax,]$result <- 1\n  return(temp[, name])\n}\n\nGetInd <- function(test, result) {\n  # Get 3 indicators and combine them to evaluate each model\n  # Args:\n  #\t  test: ID Entr Sor Date DOW WOY TimeEntr TimeSor Sens SensEntr SensSor\n  #\t  result: result of Model in format: ID, Entr, Sor, SensEntr, SensSor, Sens, (DOW,) Tmin, Tmax\n  \n  Ind <-  test %>%\n    group_by(ID) %>%\n    summarise(Tpos = sum(result[result == 1]), Fneg = n() - Tpos, Ind1 = Tpos/(Tpos+Fneg), Ind2 = Fneg/(Tpos+Fneg) )\n  # Ind1: Sensitivity, Recall\n  # Ind2: Miss rate\n  \n  result <- inner_join(test.period, result, by=\"DOW\")\n  result$Mark <- 0\n  \n  # keep names\n  #\tname <- names(result)   #useless ?\n  # temp <- inner_join(test, result, by = c(\"ID\", \"Entr\", \"Sor\", \"SensEntr\", \"SensSor\", \"Sens\", \"DOW\"))\n  temp <- inner_join(test, result, by = c(\"ID\", \"OD\", \"DOW\"))\n\n  temp[temp$TimeSor >= temp$Tmin & temp$TimeSor <= temp$Tmax,]$Mark <- 1\n  \n  #Ind3 <- result %>% group_by(ID) %>% summarise(nMark = sum(Mark[Mark==1]), t = (n() - nMark), Ind3 = t/ n() )\n  Ind3 <- temp %>% group_by(ID) %>% summarise(nMark = sum(Mark[Mark==1]), t = (n() - nMark), Ind3 = t/ n() )\n  # Ind3: fake alert\n  \n  Ind <- inner_join(Ind,Ind3, by = \"ID\")\n  Ind <- Ind[, c(\"ID\", \"Ind1\", \"Ind2\", \"Ind3\")]\n  # !!! to be justified or modified\n  Ind$Ind <- Ind$Ind1 - Ind$Ind3 / param.ind3\n  return(Ind)\n}\n\nSens <- function (Transactions){\n  # Decide the direction of each transaction (A789)\n  # Args:\n  #\t  Transactions:\tID, Entr, Sor, Date, DOW, WOY, TimeEntr, TimeSor, Voie, SensEntr, SensSor\n  # Returns:\n  #\t  Transactions:\tID, Entr, Sor, Date, DOW, WOY, TimeEntr, TimeSor, Voie, Sens, SensEntr, SensSor\n  Transactions <- Transactions %>% select(ID,Entr,Sor,TimeEntr,TimeSor,DOW,WOY,Date,Voie,SensEntr, SensSor)\n  Transactions$Sens <- 0\n  for (i in 1:nrow(Transactions)){\n    if (Transactions$Entr[i] == 0 & ( Transactions$Sor[i] %in% garesorder$Cde) ){ #Si Entr = 0 et Sor dans A789\n      if (Transactions$Sor[i] == 25006001 | Transactions$Sor[i] == 25006014 | \n          Transactions$Sor[i] == 25006019 | Transactions$Sor[i] == 25006026) { # Ceux dont les voies >= 20 sont en sens 1\n        #Canet de mereuil, Antibes ouest, Saint Isidore Ech Ouest, La Turibe Ech Est\n        if (Transactions$Voie[i] >= 20 ){ Transactions$Sens[i] <- 1 \n        } else \n        { Transactions$Sens[i] <- 2 }\n      } else \n        if (Transactions$Sor[i] == 25006010 | Transactions$Sor[i] == 25006011 | Transactions$Sor[i] == 25006013 |\n            Transactions$Sor[i] == 25006016 | Transactions$Sor[i] == 25006021 | Transactions$Sor[i] == 25006020 | \n            Transactions$Sor[i] == 25006027 | Transactions$Sor[i] == 25006012){ #Ceux dont les voies >= 20 sont en sens 2\n          #Fréjus, Les Adrets, Antibes Est, Cagnes Est, Saint Isidore ech Est, Saint Isidore PV, La Turbie PV, Antibes PV\n          if (Transactions$Voie[i] >= 20 ){ Transactions$Sens[i] <- 2 \n          } else \n          { Transactions$Sens[i] <- 1 }\n        } else \n          if (Transactions$Sor[i] == 25006024){ #Sophia\n            Transactions$Sens[i] <- 1  #Entrée seule\n          } else \n            if (Transactions$Sor[i] == 25006017){ Transactions$Sens[i] <- 1\n            } else\n              if (Transactions$Sor[i] == 25006015){ Transactions$Sens[i] <- 2\n              }\n    } else \n      if (  (Transactions$Entr[i] %in% garesorder$Cde) & \n            (Transactions$Sor[i] %in% garesorder$Cde) ) { #Entrée et sortie dans A789\n        if (match(Transactions$Entr[i],garesorder$Cde) < match(Transactions$Sor[i],garesorder$Cde)){\n          Transactions$Sens[i] <- 1\n        } else \n        { Transactions$Sens[i] <- 2\n        }\n      }\n  }\n  return( Transactions)\n}\n\nSO <- function (Transactions){\n  Transactions <- Transactions %>% select(ID,Entr,Sor,TimeEntr,TimeSor,DOW,WOY,Date,Voie,Sens, SensEntr, SensSor)\n  Transactions$Date <- as.character(Transactions$Date)\n  \n  #Create the useful indicators for fusion :\n  # sf (bool) if the OD is in SF\n  # Time = The time to consider while calculating the difference with the previous OD  : TimeEntr if it is not 0, else TimeSor\n  # diff = the time difference with the previous OD\n  # indic (bool) : if diff <= 1, and NA are replaced with False\n  intermediaire <- Transactions %>%\n    group_by(ID,Date,Sens) %>%\n    arrange(TimeSor) %>%\n    mutate(sf = (TimeEntr != 0), Time = (TimeEntr + TimeSor)-(sf*TimeSor) , diff = Time - lag(TimeSor), indic = (diff <= 1 & !is.na(diff)) )\n  \n  #Create afusioner : the ODs to be combined.\n  # diff <=1 or the next OD's diff <= 1\n  afusionner <- intermediaire %>%\n    filter (indic | lead(indic,default = FALSE) ) %>%\n    SO.aux\n  \n  #Select all the ODs non concerned by a fusion\n  anepasfusionner <- intermediaire %>%\n    filter( !(indic | lead(indic,default = FALSE)) )\n  \n  return( rbind(afusionner,anepasfusionner) %>%\n            ungroup() %>%\n            select(ID,Entr,Sor,TimeEntr,TimeSor,DOW,WOY,Date,Voie,Sens, SensEntr, SensSor) %>%\n\t\t\t\t\t\ttbl_df()\n\t\t\t\t) \n}\n\nSO.aux <- function(intermediaire){\n  # Aux function for SO\n  # Takes as argument the ODs to be fusioned\n  # much less test to do than the previous version\n  i <- 2\n  while (i  <= nrow(intermediaire)){\n    if (intermediaire$indic[i]){\n      if (intermediaire$sf[i-1]){\n        newrow <- data.frame( ID = intermediaire$ID[i], Entr = intermediaire$Entr[i-1], Sor = intermediaire$Sor[i], TimeEntr = intermediaire$TimeEntr[i-1],\n                              TimeSor = intermediaire$TimeSor[i], DOW = intermediaire$DOW[i], WOY = intermediaire$WOY[i], Date = intermediaire$Date[i],\n                              Voie = -1, Sens = intermediaire$Sens[i], sf = intermediaire$sf[i], Time = intermediaire$Time[i], diff =intermediaire$diff[i],\n                              indic = intermediaire$indic[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSensEntr = intermediaire$SensEntr[i-1],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSensSor = intermediaire$SensSor[i])\n      } else {\n        newrow <- data.frame( ID = intermediaire$ID[i], Entr = intermediaire$Sor[i-1], Sor = intermediaire$Sor[i], TimeEntr = intermediaire$TimeSor[i-1],\n                              TimeSor = intermediaire$TimeSor[i], DOW = intermediaire$DOW[i], WOY = intermediaire$WOY[i], Date = intermediaire$Date[i],\n                              Voie = -1, Sens = intermediaire$Sens[i], sf = intermediaire$sf[i], Time = intermediaire$Time[i], diff =intermediaire$diff[i],\n                              indic = intermediaire$indic[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSensEntr = intermediaire$SensSor[i-1],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSensSor = intermediaire$SensSor[i])\n      }\n      if (i ==2){\n        intermediaire <- rbind(\n          newrow,\n          intermediaire[(i+1):nrow(intermediaire),])\n      } else if( i == nrow(intermediaire)){\n        intermediaire <- rbind(intermediaire[1:(i-2),],\n                               newrow\n        )\n      }else{\n        intermediaire <- rbind(intermediaire[1:(i-2),],\n                               newrow,\n                               intermediaire[(i+1):nrow(intermediaire),])\n        \n      }\n      intermediaire$Date <- as.character(intermediaire$Date)\n      intermediaire$ID <- as.character(intermediaire$ID)\n      i <- i-1\n    }\n    i <- i+1\n  }\n  return(intermediaire)\n}\n\ninverse.after.SO <- function( Transactions ) {\n#Inversing Entr & Sor for the SO, if Sens = 2\n#TO BE APPLYED AFTER SO\n  nottouch <- Transactions %>% filter (Entr != 0 | Sens != 2)\n  touch <- Transactions %>% filter (Entr == 0 & Sens == 2)\n  if(nrow(touch) > 0){\n#     touch $ Entr <- touch $ Sor\n#     touch $ Sor <- 0\n    touch <- touch %>% mutate(\n      Entr = Sor,\n      Sor = 0,\n      SensEntr = SensSor,\n      SensSor = 0\n    )\n  }\n  return( rbind(nottouch,touch))\n}\n\ngetModel.units <- function ( Transactions ){\n  result <- Transactions %>%\n    group_by(ID) %>%\n    summarise(\n      D1 = sum(DOW == 1),\n      D2 = sum(DOW == 2),\n      D3 = sum(DOW == 3),\n      D4 = sum(DOW == 4),\n      D5 = sum(DOW == 5),\n      D6 = sum(DOW == 6),\n      D0 = sum(DOW == 0),\n      \n      noPsg = n(),\n      noWE = D6+D0,\n      noW = noPsg - noWE,\n   \n      SD = sd(c(D1,D2,D3,D4,D5,D6,D0)),\n      SDW = sd(c(D1,D2,D3,D4,D5)),\n      SDprnoPsg = SD / noPsg,\n      SDWprnoW = SDW / noW,\n      sumSD = SDWprnoW + SDprnoPsg,\n      \n      avg = noPsg / 7,\n      avgWE = noWE / 2,\n      avgW = noW / 5,\n      model = chose.model(SDWprnoW)\n    ) %>%\n    select (ID, model)\n  \n  return(result)\n}\n\nchose.model <-function ( SDWprnoW ) {\n  # Input : ID, SDWprnoW\n  if( is.na(SDWprnoW)) return(NA)\n  \n  if ( SDWprnoW > param.SDWprnoW ) model <- 2 \n  else  model <- 1\n\n  return(model)\n}\n\nModel.for.a.decade <- function ( Transactions, decades, units){\n#### Apply the Model of the given decade, and of the model units of each person\n  result <- NULL\n  withmodel <- inner_join(Transactions, units )\n  \n  for (k in 0:2){\n    applymodel <- withmodel %>%\n      filter (model == k )\n    if ( nrow(applymodel) >= 1 ){\n      applymodel <- Model(transaction = applymodel, model.decades = decades , model.units = k)\n      result <- rbind(result,applymodel)\n    }\n  }\n  return ( result )\n}\n\nModel <- function(transaction, model.decades, model.units) {\n  # Run the model over the transaction set\n  # Args:\n  #\t  transaction:\tID, Entr, Sor, Date, DOW, WOY, TimeEntr, TimeSor, Voie\n  #   model: 0,1,2,10,11,12,20,21,22\n  # Returns:\n  #\t  transaction:\tID, Entr, Sor, DOW, Tmin, Tmax, Model\n  #   transaction:  ID, OD = paste0(Entr,Sor,Sens), ...\n  \n  model <- model.decades * 10 + model.units\n  \n  if (model == 0){\n    T.matin <- transaction %>%\n      filter(TimeSor < 12 ) %>%\n      group_by(ID, OD) %>%\n      summarise(noPsg = n(), T = mean(TimeSor), SD = sd(TimeSor), Tmin = T -SD, Tmax = T + SD)\n    \n    T.aprem <- transaction %>%\n      filter(TimeSor >= 12 ) %>%\n      group_by(ID, OD) %>%\n      summarise(noPsg = n(), T = mean(TimeSor), SD = sd(TimeSor), Tmin = T -SD, Tmax = T + SD)\n    \n    T <- rbind(T.matin, T.aprem)\n    T <- T %>% filter(noPsg > param.min.noPsg)\n    \n    # add DOW\n    T$DOW <- 0\n    temp <- T\n    for(i in 1:6) {\n      # add DOW to the T\n      temp$DOW <- i\n      T <- rbind(T, temp)\n    }\n    T$Model <- model\n    result <- T\n    ##########\n    # end of model 00\n  } else \n\tif (model == 1) {\n    temp <- transaction \n    temp$weekday <- 0\n    temp[temp$DOW %in% c(1:5), ]$weekday <- 1\n    \n    T.matin <- temp %>%\n      filter(TimeSor < 12 ) %>%\n      group_by(ID, OD, weekday) %>%\n      summarise(noPsg = n(), T = mean(TimeSor), SD = sd(TimeSor), Tmin = T -SD, Tmax = T + SD)\n    \n    T.aprem <- temp %>%\n      filter(TimeSor >= 12 ) %>%\n      group_by(ID, OD, weekday) %>%\n      summarise(noPsg = n(), T = mean(TimeSor), SD = sd(TimeSor), Tmin = T -SD, Tmax = T + SD)\n    \n    T <- rbind(T.matin, T.aprem)\n    T <- T %>% filter(noPsg > param.min.noPsg)\n    \n    # add DOW\n    # for weekdays\n    result <- T %>% filter(weekday == 1)\n    result$DOW <- 1\n    temp <- result\n    for(i in 2:5) {\n      # add DOW to the result\n      temp$DOW <- i\n      result <- rbind(result, temp)\n    }\n    \n    # for weekends\n    T <- T %>% filter(weekday == 0)\n    if (nrow(T) > 0){\n      T$DOW <- 0\n      temp <- T\n      temp$DOW <- 6\n      T <- rbind(T, temp)\n    }\n    \n    result <- rbind(result, T)\n    result$weekday <- NULL\n    result$Model <- model\n    ##########\n    # end of model 01\n  } else \n\tif (model == 2) {\n    T.matin <- transaction %>%\n      filter(TimeSor < 12 ) %>%\n      group_by(ID, OD, DOW) %>%\n      summarise(noPsg = n(), T = mean(TimeSor), SD = sd(TimeSor), Tmin = T -SD, Tmax = T + SD)\n    \n    T.aprem <- transaction %>%\n      filter(TimeSor >= 12 ) %>%\n      group_by(ID, OD, DOW) %>%\n      summarise(noPsg = n(), T = mean(TimeSor), SD = sd(TimeSor), Tmin = T -SD, Tmax = T + SD)\n    \n    T <- rbind(T.matin, T.aprem)\n    T <- T %>% filter(noPsg > param.min.noPsg)\n    \n    T$Model <- model\n    result <- T\n    ##########\n    # end of model 02\n  } else \n\tif(model == 10) {\n    # result <- data.frame(ID=\"\", Entr=0, Sor=0, SensEntr = 0, SensSor = 0, Sens = 0, SD=0, T=0, Tmin=0, Tmax=0, noPsg=0)\n\t  result <- data.frame(ID=\"\", OD=\"\", SD=0, T=0, Tmin=0, Tmax=0, noPsg=0)\n\n    result$ID <- as.character(result$ID)\n    for (i in 1:nrow(ID.list)) {\n      temp <- transaction %>% filter(ID == ID.list$ID[i])\n\t\t\t max.cluster <- length(unique(temp$TimeSor))\n      if(nrow(temp) >= param.min.nb.for.cluster & max.cluster > 1) {\n        # if not many passages, we will not cluster\n        # decide nb of cluster\n        clus<- clusGap(temp %>% select(TimeSor), kmeans, max(min(param.max.nb.cluster, max.cluster),2))\n        n.cluster <- with(clus,maxSE(Tab[,\"gap\"],Tab[,\"SE.sim\"]))\n        \n        set.seed(1234)\n        temp.kmeans <-   kmeans(temp[, \"TimeSor\"], centers = n.cluster)\n        temp$cluster <- temp.kmeans$cluster\n        T <- temp %>%\n          group_by(ID, OD, cluster) %>%\n          summarise(noPsg = n(), T = mean(TimeSor), SD = sd(TimeSor), Tmin = T -SD, Tmax = T + SD)\n        \n        # remove line with SD = N.A.\n        T <- T %>% filter(noPsg > 1)\n        \n        T$cluster <- NULL\n        result <- rbind(result, T)\n      } # end of if\n    } # end of loop i\n    result <- result[-1,]\n    result <- result %>% filter(noPsg > param.min.noPsg)\n    \n    # add DOW\n    result$DOW <- 0\n    temp <- result\n    for(i in 1:6) {\n      # add DOW to the T\n      temp$DOW <- i\n      result <- rbind(result, temp)\n    }\n    \n    result$Model <- model\n    ##########\n    # end of model 10\n  } else \n\tif(model == 11) {\n    temp1 <- transaction \n    temp1$weekday <- 0\n    temp1[temp1$DOW %in% c(1:5), ]$weekday <- 1\n    \n    # clustering TimeSor\n    # result <- data.frame(ID=\"\", Entr=0, Sor=0, SensEntr = 0, SensSor = 0, Sens = 0, weekday = 0, SD=0, T=0, Tmin=0, Tmax=0, noPsg=0)\n\t  result <- data.frame(ID=\"\", OD=\"\", weekday = 0, SD=0, T=0, Tmin=0, Tmax=0, noPsg=0)\n\n\t\tresult$ID <- as.character(result$ID)\n    for (i in 1:nrow(ID.list)) {\n      for (j in 0:1) {\n        temp <- temp1 %>% filter(ID == ID.list$ID[i] & weekday == j)\n\t\t\t max.cluster <- length(unique(temp$TimeSor))\n      if(nrow(temp) >= param.min.nb.for.cluster & max.cluster > 1) {\n          # if not many passages, we will not cluster\n          # decide nb of cluster\n\t\t\t\t\tclus<- clusGap(temp %>% select(TimeSor), kmeans, max(min(param.max.nb.cluster, max.cluster),2))\n          n.cluster <- with(clus,maxSE(Tab[,\"gap\"],Tab[,\"SE.sim\"]))\n          \n          set.seed(1234)\n          temp.kmeans <-   kmeans(temp[, \"TimeSor\"], centers = n.cluster)\n          temp$cluster <- temp.kmeans$cluster\n          T <- temp %>%\n            group_by(ID, OD, weekday, cluster) %>%\n            summarise(noPsg = n(), T = mean(TimeSor), SD = sd(TimeSor), Tmin = T -SD, Tmax = T + SD)\n          \n          # remove line with SD = N.A.\n          T <- T %>% filter(noPsg > 1)\n          \n          T$cluster <- NULL\n          result <- rbind(result, T)\n        } # end of if\n      } # end of loop j\n    } # end of loop i\n    \n    result <- result[-1,]\n    result <- result %>% filter(noPsg > param.min.noPsg)\n    \n    T <- result  \n    # add DOW\n    # for weekdays\n    result <- T %>% filter(weekday == 1)\n    result$DOW <- 1\n    temp <- result\n    for(i in 2:5) {\n      # add DOW to the result\n      temp$DOW <- i\n      result <- rbind(result, temp)\n    }\n    \n    # for weekends\n    T <- T %>% filter(weekday == 0)\n    if (nrow(T) > 0){\n      T$DOW <- 0\n      temp <- T\n      temp$DOW <- 6\n      T <- rbind(T, temp)\n    }\n    \n    result <- rbind(result, T)\n    result$weekday <- NULL\n    \n    result$Model <- model\n    \n    ##########\n    # end of model 11\n  } else \n\tif(model == 12) {\n    # result <- data.frame(ID=\"\", Entr=0, Sor=0, SensEntr = 0, SensSor = 0, Sens = 0, DOW=0, SD=0, T=0, Tmin=0, Tmax=0, noPsg=0)\n\t  result <- data.frame(ID=\"\", OD=\"\", DOW = 0, SD=0, T=0, Tmin=0, Tmax=0, noPsg=0)\n\n    result$ID <- as.character(result$ID)\n    for (i in 1:nrow(ID.list)) {\n      for (j in 0:6) {\n        temp <- train %>% filter(ID == ID.list$ID[i] & DOW == j)\n        max.cluster <- length(unique(temp$TimeSor))\n\t\t\t\tif(nrow(temp) >= param.min.nb.for.cluster & max.cluster > 1) {\n          # if not many passages, we will not cluster\n          # decide nb of cluster\n\t\t\t\t\tclus<- clusGap(temp %>% select(TimeSor), kmeans, max(min(param.max.nb.cluster, max.cluster),2))\n\t\t\t\t\t\n          n.cluster <- with(clus,maxSE(Tab[,\"gap\"],Tab[,\"SE.sim\"]))\n          \n          set.seed(1234)\n          temp.kmeans <-   kmeans(temp[, \"TimeSor\"], centers = n.cluster)\n          temp$cluster <- temp.kmeans$cluster\n          T <- temp %>%\n            group_by(ID, OD, DOW, cluster) %>%\n            summarise(noPsg = n(), T = mean(TimeSor), SD = sd(TimeSor), Tmin = T -SD, Tmax = T + SD)\n          \n          # remove line with SD = N.A.\n          T <- T %>% filter(noPsg > 1)\n          \n          T$cluster <- NULL\n          result <- rbind(result, T)\n        } # end of if\n      } # end of loop j\n    } # end of loop i\n    \n    result <- result[-1,]\n    result <- result %>% filter(noPsg > param.min.noPsg)\n    \n    result$Model <- model\n    \n    ##########\n    # end of model 12\n  } else \n\t{\n    ####################\n    ### model.2:\tOD -> Space -> Time\n    ####################\n    #COMPTAGE DES TRAJETS PAR OD\n    Compteur <- transaction %>% \n      group_by(ID, Entr,Sor) %>%\n      summarise( n = n())\n    #DECISION AUTOMATIQUE DES TRONCONS FREQUENTS\n    Troncon_Selection <- Compteur %>% \n      group_by(ID) %>%\n      filter (n > (param.model.2 * max(n)))\n    VIP2_espace <- inner_join(transaction, Troncon_Selection, by = c(\"ID\",\"Entr\",\"Sor\"))\n    VIP2_espace <- tbl_df(VIP2_espace)\n    #Create OD.list for the kmeans\n    OD.list <- VIP2_espace %>% group_by( ID,Entr,Sor, Sens) %>% summarise()\n    \n    if(model == 20) {\n      # result <- data.frame(ID=\"\", Entr=0, Sor=0, SensEntr = 0, SensSor = 0, Sens = 0, DOW=0, SD=0, T=0, Tmin=0, Tmax=0, noPsg=0)\n\t\t\tresult <- data.frame(ID=\"\", OD=\"\", DOW=0, SD=0, T=0, Tmin=0, Tmax=0, noPsg=0)\n\n      result$ID <- as.character(result$ID)\n      for (k in 1:nrow(OD.list)){\n        temp <- VIP2_espace %>% filter(ID == OD.list$ID[k] &  Entr == OD.list$Entr[k] & Sor == OD.list$Sor[k] )\n        # base to be verified\n\t\t\t\tmax.cluster <- length(unique(temp$TimeSor))\n\t\t\t\tif(nrow(temp) >= param.min.nb.for.cluster & max.cluster > 1) {\t\t\t\t\n          # if not many passages, we will not cluster\n          # decide nb of cluster\n          clus<- clusGap(temp %>% select(TimeSor), kmeans, max(min(param.max.nb.cluster, max.cluster),2))\n          n.cluster <- with(clus,maxSE(Tab[,\"gap\"],Tab[,\"SE.sim\"]))\n          \n          set.seed(1234)\n          temp.kmeans <-   kmeans(temp[, \"TimeSor\"], centers = n.cluster)\n          temp$cluster <- temp.kmeans$cluster\n          T <- temp %>%\n            group_by(ID, OD, DOW, cluster) %>%\n            summarise(SD = sd(TimeSor), T = mean(TimeSor),Tmin = T -SD, Tmax = T + SD, noPsg = n())\n          T <- T %>% filter(noPsg>1)\n          T$cluster <- NULL\n          result <- rbind(result, T) \n        } # end of if\n      } # end of k loop\n      result <- result[-1,]\n      result$Model <- model\t\n      \n      ##########\n      # end of model 20\n    } else \n\t\tif(model == 21) {\n      VIP2_espace$weekday <- 0\n      VIP2_espace[VIP2_espace$DOW %in% c(1:5), ]$weekday <- 1\n      \n      # result <- data.frame(ID=\"\", Entr=0, Sor=0, SensEntr = 0, SensSor = 0, Sens = 0, DOW=0, SD=0, T=0, Tmin=0, Tmax=0, noPsg=0)\n\t\t\tresult <- data.frame(ID=\"\", OD=\"\", DOW = 0, SD=0, T=0, Tmin=0, Tmax=0, noPsg=0)\n\n\t\t\tresult$ID <- as.character(result$ID)\n      for (k in 1:nrow(OD.list)){\n        for (j in 0:1){\n          temp <- VIP2_espace %>% filter(ID == OD.list$ID[k] &  Entr == OD.list$Entr[k] & Sor == OD.list$Sor[k] & weekday == j)\n\t\t\t\t\tmax.cluster <- length(unique(temp$TimeSor))\n\t\t\t\t\tif(nrow(temp) >= param.min.nb.for.cluster & max.cluster > 1) {\t\t\t\t\n\t\t\t\t\t\t# if not many passages, we will not cluster\n\t\t\t\t\t\t#\tdecide nb of cluster\n\t\t\t\t\t\tclus<- clusGap(temp %>% select(TimeSor), kmeans, max(min(param.max.nb.cluster, max.cluster),2))\n            n.cluster <- with(clus,maxSE(Tab[,\"gap\"],Tab[,\"SE.sim\"]))\n            \n            set.seed(1234)\n            temp.kmeans <-   kmeans(temp[, \"TimeSor\"], centers = n.cluster)\n            temp$cluster <- temp.kmeans$cluster\n            T <- temp %>%\n              group_by(ID, OD, DOW, cluster) %>%\n              summarise(SD = sd(TimeSor), T = mean(TimeSor),Tmin = T -SD, Tmax = T + SD, noPsg = n())\n            T <- T %>% filter(noPsg>1)\n            T$cluster <- NULL\n            result <- rbind(result, T) \n          } # end of if\n        } # end of j loop\n      } # end of k loop\n      result <- result[-1,]\n      result$Model <- model\n      ##########\n      # end of model 21\n    } else \n\t\tif(model == 22) {\n      # result <- data.frame(ID=\"\", Entr=0, Sor=0, SensEntr = 0, SensSor = 0, Sens = 0, DOW=0, SD=0, T=0, Tmin=0, Tmax=0, noPsg=0)\n\t\t\tresult <- data.frame(ID=\"\", OD=\"\", DOW = 0, SD=0, T=0, Tmin=0, Tmax=0, noPsg=0)\n\n\t\t\tresult$ID <- as.character(result$ID)\n      for (k in 1:nrow(OD.list)){\n        for (j in 0:6){\n          temp <- VIP2_espace %>% filter(ID == OD.list$ID[k] & DOW == j &  Entr == OD.list$Entr[k] & Sor == OD.list$Sor[k] )\n\t\t\t\t\tmax.cluster <- length(unique(temp$TimeSor))\n\t\t\t\t\tif(nrow(temp) >= param.min.nb.for.cluster & max.cluster > 1) {\t\t\t\t\n\t\t\t\t\t\t# if not many passages, we will not cluster\n\t\t\t\t\t\t# decide nb of cluster\n\t\t\t\t\t\tclus<- clusGap(temp %>% select(TimeSor), kmeans, max(min(param.max.nb.cluster, max.cluster),2))\n            n.cluster <- with(clus,maxSE(Tab[,\"gap\"],Tab[,\"SE.sim\"]))\n            \n            set.seed(1234)\n            temp.kmeans <-   kmeans(temp[, \"TimeSor\"], centers = n.cluster)\n            temp$cluster <- temp.kmeans$cluster\n            T <- temp %>%\n              group_by(ID, OD, DOW, cluster) %>%\n              summarise(SD = sd(TimeSor), T = mean(TimeSor),Tmin = T -SD, Tmax = T + SD, noPsg = n())\n            T <- T %>% filter(noPsg>1)\n            T$cluster <- NULL\n            result <- rbind(result, T) \n          } # end of if\n        } # end of j loop \n      } # end of k loop \n      \n      result <- result[-1,]\n\t\t\t\n\t\t\tif(nrow(result) > 0)\tresult$Model <- model\n      ##########\n      # end of model 22\n    }\n  } # end of if\n  \n\tif(nrow(result) > 0){\n\tresult$DOW <- as.integer(result$DOW)\n  result <- tbl_df(result)\n  result <- result %>% select(ID, OD, DOW, Tmin, Tmax, Model, noPsg)\n\t}\n  return(result )\n} # end of fuction Model\n",
    "created" : 1443636163020.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4290126255",
    "id" : "B9AF2070",
    "lastKnownWriteTime" : 1443693785,
    "path" : "~/SVN/1-click_Dev/SA_function.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "type" : "r_source"
}